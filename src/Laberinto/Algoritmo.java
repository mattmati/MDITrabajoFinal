/*
Utilizando recursive backtracking:
- Celda inicial[0][0], la marco como visitada
- Busco celdas adyacentes sin visitar, elijo una de las 2 al azar
- Me muevo a esa celda
- La marco como celda actual, marco como visitada
- Repetis hasta que no hayan celdas sin visitar
Cuando llego a un deadend y debo volver a visitar una celda ya visitada, esa celda se agrega al stack
Eventualmente todas las celdas se a√±aden al stack hasta volver a la celda inicial [0][0]

 */
package Laberinto;

public class Algoritmo {

    public Algoritmo() {
    }
    
    
    
    
    
}
